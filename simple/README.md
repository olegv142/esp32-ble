This is the collection of experimental ESP32 BLE projects for Arduino targeting telemetry / monitoring applications. The main goals were testing various scenarios of using BLE stack in order to reveal its limitations and find workarounds.

## Simple receiver / transmitter examples
The **ble_receiver** / **ble_transmitter** are examples of creating one way communication channel with automatic re-connection. The code also illustrates using watchdog for improved reliability and maximizing transmission power for extending range.

The **ble_uart_tx** example adds receiving data for transmission from the (USB virtual) serial port, increasing the MTU and the ability to add a hexadecimal suffix to the device name so that it can be distinguished in case there are several devices around with the same firmware.

The **ble_uart_rx** example adds sending received data to hardware serial port, increasing the MTU and using hardware reset on watchdog timeout for better reliability. It also has the option to establish connection to the transmitter without scan in case its address is known.

## Dual role example
The **ble_uart_dual** example illustrates creating dual role device capable of connecting to the transmitter as central and acting as peripheral accepting connections from other central. Here we start to hit BLE stack limitations / bugs. In particular the BLEServerCallbacks methods should be called on every connect / disconnect of the remote central. It turns out that they also called when we act as central and connecting to the remote peripheral. Hopefully we can workaround this issue by just not strictly relying on that callbacks.

## Using watchdog for better reliability
The BT stack is complex and not well tested bunch of software. Using it one can easily be trapped onto the state where there is no way out. The biggest problem is that connect routine may hung forever. Although the connect call has timeout parameter, it does not help. The call may complete on timeout without errors, but the connection will not actually be established. That's why we are using watchdog to detect connection timeout. Its unclear if soft reset by watchdog is equivalent to the power cycle or reset by pulling low EN pin. That's why there is an option to implement hard reset on connect timeout by hard wiring some output pin to EN input of the chip. See **ble_uart_rx** as an example of such approach implementation. There is an option to self reset receiver after connection for testing, see SELF_RESET_AFTER_CONNECTED macro.

## Serial data flow control
Whenever data is transmitted over serial channel its important to ensure the receiver is able to process data we are sending to it. Otherwise the data sent may be silently lost. When using UART the receiver is typically set RTS or DTR signal low to indicate its ready to process new data. To implement flow control this signal should be connected to CTS input of the transmitter and the latter should be configured to use it. The **ble_uart_rx** code has an example of such configuration. Note that if serial data receiver is unable to process the data (for ex. the serial port is not open) the transmitter will just hung on writing the new data. In such case **ble_uart_rx** will be reset by watchdog.

The USB virtual serial port used by **ble_uart_tx** example also has potential issues related to flow control. The problem is that Arduino implementation of such serial port does not have flow control at all. The host may keep sending data even in case the receiving buffer in ESP32 is full so the new data will be silently dropped. The buffer size is 256 bytes by default. The **ble_uart_tx** example increases this buffer up to 4096 bytes to avoid potential overflow issues. Note that the possibility to loose data in a buffer still exists but yet the data may be lost in BLE transmission anyway.

## Notes on data integrity
In general there are two possible data integrity models that can be implemented in the transmission channel. The strongest is data stream integrity where data can't be lost or reordered across the entire data stream (just like TCP/IP). The implementation of such integrity model is hard and typically not needed. The second model is message integrity when the message of limited length is either delivered unmodified or not delivered at all. So messages may be dropped or reordered but can't be modified (just like UDP). To implement such integrity model over unreliable data link one should take care of the following:
* There should be means of detecting message boundaries in the data stream even if the stream is corrupted
* There should be means of validating message integrity so the modified messages will be dropped

The test scripts in the **test** folder implement message boundary detection by enclosing message between start/end markers that can't be present in the message body. The test scripts detect corrupt messages by repeating message payload twice in the message body. The less space consuming approach typically used is to add checksum to the message.

The **ble_uart_rx** uses its own start/end markers while sending received data fragments to the serial port. It also sends empty start/end marker pair after connect / re-connect as the start of the stream tag. The receiving application may use start of the stream tag to drop buffered incomplete messages received before disconnection. See **test/receive.py** for example of the stream parsing. If you don't want **ble_uart_rx** to send start/end markers, undefine UART_BEGIN and UART_END in the code. After that **ble_uart_rx** will behave as transparent serial port.

## Lost updates detection
The BLE transmits data by updating the so called *characteristic*. So the data are delivered in chunks with every chunk corresponding to the particular characteristic update. In theory updates should be delivered in order or the communication channel should go to disconnected state. In practice this assertion may be violated due to the bugs in the complex BLE stack implementation. See **Notes about NimBLE** for discussion of the testing results. To be able to detect missing updates the transmitter inserts sequence tag as the first symbol of the characteristic value. The sequence tag is assigned a values from 16 characters sequence 'a', 'b', .. 'p'. The next update uses next letter as sequence tag. The 'p' letter is followed by the 'a' again. The sequence tag symbol is followed by the data to be transmitted. The receiving application may use sequence tags to detect lost chunks of data transmitted or just ignore them.  See **test/receive.py** for example of the tags validation and missing updates detection. If you don't need sequence tags, undefine USE_SEQ_TAG in **ble_uart_tx.ino** code. Note that using sequence tags by itself does not guarantee data integrity. They just help to identify the root cause of the data stream corruption during testing.

## Notes about NimBLE
The **nim_ble_uart_rx** / **nim_ble_uart_tx** are two examples adopted for using NimBLE stack instead of Bluedroid used by default. The NimBLE stack has 2 times smaller amount of code, much less RAM usage and better written in general. For example there are no such stupid things in API as passing class instances with a lot of data by value. Nevertheless testing has revealed severe problems related to using NimBLE stack:
1. The automatic gain control does not work. Placing transmitter close to receiver severe disrupts communications.
2. There is no guarantee of the characteristic update delivery. Updates may be lost anytime but channel is still kept in connected state.
3. In case of bad reception the communication channel may become permanently broken. It can fall to some pathological state where even re-connection does not repair communication. Only transmitter reset is able to repair it so the data may be transmitted again.
